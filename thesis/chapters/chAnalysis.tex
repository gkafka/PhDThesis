\chapter{Neutral Current Spectrum Prediction}
\label{ch:Prediction}

Any rigorous scientific analysis must have a well defined analysis procedure. This chapter describes the bulk of that procedure for the FD NC disappearance analysis. The methods presented use the NC event selection discussed in ch.~\ref{ch:Selection} to predict the FD energy spectrum.

\section{The CAFAna Analysis Chain}

The analysis presented in this thesis was performed in a software framework called CAFAna that analyzes Common Analysis Format files, or CAFs. The design principles of CAFAna recognize that all neutrino analyses have to perform essentially the same tasks, such as decomposing a detector spectrum into different components or applying oscillation weights to a particular event spectrum. A given task might have multiple implementations, but while the inner details are different, the number and type of end products are the same. Thus CAFAna has a fixed general analysis chain with the ability to easily swap specific implementations of any given piece of the chain.

The general analysis chain shown in Fig.~TODO illustrates how a near to far detector analysis can be neatly separated into smaller components that can be implemented individually. The first three components, IDecomp, IExtrap, and IPrediction, are responsible for the creation of a predicted FD spectrum. Each of these classes are pure virtual and simply declare the necessary functions for each class to hook into the next. The remainder of this chapter discusses these three classes in more detail; the classes that follow in the analysis chain are for the fitting and final results and are described in ch.~\ref{ch:Results}.
%\begin{figure}[h]
%  \centering
%  \includegraphics[width=1\textwidth]{figures/.png}
%  \caption[CAFAna Analysis Chain]{The CAFAna analysis chain.}
%  \label{fig:CAFAnaDecomp}
%\end{figure}

Before delving into the analysis classes, it is worth briefly mentioning the basic unit of CAFAna, the Spectrum. The primary use of this class is to store the histogram of a specific variable and two methods of normalization, POT and livetime. Nearly every analysis class handles Spectrum objects in some fashion, be it storing them for internal calculations, returning them as output, or both. While the Spectrum has the ability to handle two dimensional histograms on its own, the specialized class OscillatableSpectrum stores a two dimensional histogram of a user defined variable on its X axis, and true neutrino energy on its Y axis. The function OscillatableSpectrum::Oscillated applies oscillation weights to all of the stored histogram's rows based on the true energy, then returns a one dimensional Spectrum by summing all of the contents in a column, projecting out the true energy axis.

\section{Near Detector Decomposition}

Near detector decomposition is performed within implementations of IDecomp. The output of any decomposition is simply a set of ND spectra separated by neutrino flavor and sign; thus IDecomp declares a set of functions that each return a Spectrum object with the same X axis and contain estimates of the NC, $\numu$, $\anumu$, $\nue$, and $\anue$ components. Since oscillations do not necessarily affect neutrinos and anti-neutrinos equally, a split by sign must happen at some point; it was a design choice to have that occur starting with the decomposition. The most basic implementation of IDecomp, named CheatDecomp, simply fills component histograms based on MC truth information. Fig.~TODO shows the inheritance structure for all of the decompositions discussed in this section.
%\begin{figure}[h]
%  \centering
%  \includegraphics[width=1\textwidth]{figures/.png}
%  \caption[Decomposition Inheritance Structure]{Decomposition inheritance structure.}
%  \label{fig:CAFAnaDecomp}
%\end{figure}

The decomposition used for the main analysis is the ProportionalDecomp, which splits each bin in data based on the proportion of each event type found in the MC. Fig.~TODO shows the ND decomposition based on this method. Other decompositions are used for systematic studies, including NCDecomp, NumuDecomp, NueDecomp100Up, and NueDecomp100Dn. NCDecomp and NumuDecomp assess any data/MC difference to a single component. For NCDecomp, the $\numu$, $\anumu$, $\nue$, and $\anue$ components are taken directly from MC, and the difference between these components and the total data Spectrum is taken as the NC component. For NumuDecomp, it is the NC, $\nue$, and $\anue$ components that are taken from MC. NueDecomp100Up and NueDecomp100Dn split the data proportionally as in ProportionalDecomp, but then fluctuate the $\nue$ and $\anue$ components up by $100\%$ (doubling this background) or down by $100\%$ (removing it), respectively.
%\begin{figure}[h]
%  \centering
%  \begin{tabular}{c c}
%    \includegraphics[width=.48\textwidth]{figures/.png} &
%    \includegraphics[width=.48\textwidth]{figures/.png} \\
%  \end{tabular}
%  \caption[ND Decomposition]{ND data decomposed into individual components. Each component is shown separately on the left and stacked on the right.}
%  \label{fig:NDDecomp}
%\end{figure}

\section{Extrapolation}

Near to far detector extrapolation occurs within implementations of IExtrap. 

\section{Far Detector Prediction}

Oscillation weights are applied within implementations of IPrediction.